## Сущности базы
Наша задача была связана с созданием слоя работы с базой данных. Представим, что перед нами стоит задача описать сущности базы данных в коде. В голове держим то, что мы хотим сложить максимально ответственности на компилятор.
В первую очередь нужно определиться, что собой являют сущности в нашем домене, как их представить в коде и как работать с ними.

### Table
Первое о чем нужно поговорить, когда обсуждаем базы - это таблицы.
>поправить код
```C#
interface ITable
{
    String TableDescriptor { get; }
    List<?> GetColumns();
}
```
Ничего сложно. Кроме того, что мы теперь должны как-то описать столбцы.

### Column
Попытаемся описать столбец таблицы как какой-то тип. Column в рамках шарпа - описание чего-то, что есть в базе, а значит мы просто делаем проекцию этих данных. Выделим ключевые его параметры:
- Название
- Тип значения
- Тип таблицы к которой он относится

```C#
public interface Column<Ttable, TValue>
{
	String TableName();	
    TValue GetFrom(DataTableReader reader);
}
```
Получим какой-то класс а-ля `Column<TTable, TValue>`. И если с типом значения еще есть представление зачем оно может понадобится, то TTable вызывает вопросы. 

> рассказать про принадлежность категории

## Уровни абстракций типов
### Column<TTable, TValue>
Типизация колонок это очень классно. А теперь представим довольно простой кейс - мы хотим передать список колонок. Объявляем аргумент типа `List<Column<TTable, TValue>>` и... Кажется, мы проиграли. Это вызвано тем, что мы пытаемся описать список однотипных объектов, но оказывается, что они не однотипные. Как было сказано ранее - у нас есть большая категория объектов Column<T1, T2>, с которой  можно выделить подкатегорию - множество Column<Backup, int>. Эта категория имеет не особо много смысл, на ней даже сложно определить какие-то операции. Да и не нужно, скорее всего. Но мы можем выделить некую "надкатегорию" IColumn<TValue> - это множество объединяющее все типы с определенным типом столбца.

### IColumn<TValue>
Попробуем еще раз - `List<IColumn<TValue>>`. И... мы все еще проиграли. Уже лучше, но мы все еще не можем сложить произвольные столбцы. Провернем еще одну операцию обобщения, выделим IColumn - категория всех возможных столбцов.

### IColumn
`List<IColumn>` - успех.

### А почему тогда не использовать IColumn?
Давайте набросаем методов, которые скорее всего нужны будут от нашего IColumn:
- SqlObjectName Title
- TValue GetFrom(DataTableReader reader);
- Генерация WhereCondition<TEntityDescriptor>

### А почему тогда не использовать IColumn?
IColumn<TTable, TValue>
(TValue => Func<TValue, Boolean>)
WhereCondition<TTable>

### А теперь собираем тип обратно
Рассмотрим цепочку преобразований Column<T,V> -> Column<V> -> Column. Это цепочка в которой мы теряем часть знаний о первоначальном объекте, которые мы не сможем нормально восстановить. Делаем вывод - каст к более общему, в общем случае, действие не обратимое. Мы начинаем работать с типом как с более общим и без грязных хаков не сможем вернуть информацию о изначальном типе.

Приходим к весьма неожиданному заключению: абстракции - это ограничения.

## Проектируем Data Access Layer
### Как писать DA не нужно
Представим простой случай: у нас есть описание какой-то модели которую мы можем достать с базы. Рассмотрим один из вариантов:
1. Написать SQL процедуру
2. Написать метод вызова процедуры и передачу параметров
3. Написать метод парсинга ответа
4. Повторить на каждый кейс, когда нужно что-то отфильтровать

> Пример кода?

Вопрос, что в этом кейсе хуже: кол-во времени, которое тратится на написание сторок или уровень багоопасности таких кусков кода, где SQL не связан с C#?

### SELECT * FROM ITable
Попытаемся использовать ITable. Для самого простого запроса от ITable нужно - название таблицы, список столбцов и возможность сконвертить результат в сущности:
- название таблицы изначально заложили в интерфейс
- с методом GetCloumns тоже определились - он будет типа List<IColumn>
С селектом все сложнее. очевидно, что логику превращения в селект будет инкапсулировать в себе класс Column, он знает название свой таблицы, столбца. Именно ему мы добавим метод GetFrom. Все что осталось - написать метод, который для каждого поля модели будет вытаскивать через IColumn значение.

### WhereCondition
Вспомнил, что в SQL есть возможность фильтровать результат с помощью WHERE. Т.е. это команда состоящая (в самом простом случае) из столбца, по которому фильтруем, какого-то оператора сравнения и значения, с которым сравнивать будем. Есть два варианта:
- WhereCondition - все просто и понятно
- WhereCondition<TEntityAccessor, TValue> - с одной стороны все понятно, с другой - вспоминаем прошлые слады, как Column превратился в 3 разных типа и уже страшно. (спойлер: так и будет)

### Нужен ли <TTable>
Попытаемся научиться на примере этого типа отвечать на вопрос - а нужен ли мне дженерик тут? Для ответа на этот вопрос продумаем как мы его использовать будем. Допустим мы добавим в наш билдер возможность принимать дескрипторы WHERE. 

Что мы получаем от TTable?
Ограничение, что метод будет работать только с условиями связанными с этой таблицей.


### Нужен ли <TValue>
А что на счет TValue?
- Мы не можем список передать
- Value мы просто приводим к строке – его тип нам неважен после создания

### Дженериков много бывает

### Join
Перейдем к самой не очевидной проблеме - Join'ы. Представим, что у нас есть параметр в билдере - ITable joinedTable. Напишем вызов:
`Process(BackupTable, null, TenantTable)`

### Join
И как нам теперь джоинить их? – IJoinable.
А если я хочу сделать больше 1 джоина? - SqlQueryBuidler

### SelectQueryBuilder
В этот момент мы понимаем, что нужен некий билдер. Представим себе такой билдер, который инкапсулирует всю описанную ранее логику. А теперь представим, что наш джоин - это функтор:
```C#
class SelectQueryBuilder<TTable,TEntity>
    where TTable : ITable<TEntity>
```

Когда мы делаем Join - мы определяем новый билдер, который начинает уже работать с другим контекстом, с той таблицей, что мы заджойнили.
```C#
class SelectQueryBuilder<TTable,TEntity, TJoined>
where TTable : ITable<TEntity>
where TTable : ITable

SelectQueryBuilder<TTable, TEntity, TJoined> 	Join<TJoined>(TJoined joinedEntity)
where TJoined : IJoinable<TTable>, ITable
```

## А что же внутри билдера?
Билдер - это, конечно, круто. А вот только что мы получаем в итоге, как нам с этим работать?

### Слои абстракции
Билдер -> Сериализованный запрос -> Резолвед контейнер -> Запрос
Результат -> Трансфер обджект (dto) -> Модель

Этапы:
1. Билдер -> Сериализованный запрос
> Расписать про то, что билдер конвертится в запрос и что это ок т.к. мы сохранность гарантируем
2. Достаем типы, которых нет
> Сериализованный запрос -> Резолвед контейнер 
3. Из контейнера в ResultDto

## Обертки над типами
### SharpVariableName, SqlObjectName, TableDescriptor
Зачем?
1. SharpVariableName - keywords валидация
2. SqlObjectName.AsSqlObject, SqlObjectName.WithoutBrackets
3. TableDescriptor = { DatabaseScheme, TableName }


## Не вошло
## Можно еще добавить
Композиция

Представим, что у нас есть три таблицы, нарисуем связи A -> B, B -> C.
Путем не сложных SQL-ных действий мы можем легко сделать связь A -> C. Конечно, что условии, что множество транзитивное.
Зачем нам это нужно? Хорошим примером являются CC.Ownership.View. 
> тут рассказ про доменную модель клауда, зачем там фильтрация

А теперь представим, что у нас есть ITable. И есть IJoin - какая-то информация, которая позволяет какому-то билдеру собрать переобразовать это в настоящий SQL. Ну и по классике:
```C#
ITable<A> a;
ITable<B> b;
ITable<C> c;
IJoinable<A, B> a2b;
IJoinable<B, C> b2c;
```


Давай представим такой метод, который будет объединять джоины:
```C#
public static JoinDescriptor<TFirst, TSecond> Composition<TFirst, TSecond, TThird, TFirstValue, TSecondValue>(
    this IJoinable<TFirst, TSecond, TFirstValue> first,
    IJoinable<TSecond, TThird, TSecondValue> second)
    where TFirst : IEntityAccessor
    where TSecond : IEntityAccessor
    where TThird : IEntityAccessor
{
    return JoinDescriptorCreator.Create(first).AndJoin(second);
}
```

И так, мы представили этот метод. Но зачем?
> В рамках домена описываем как мы конкатим джоины, чтобы получить фильтрацию.

> ColumnProvider
> Как мы парсили схему
> Кодген?