# Branching

Ветки в git позволяют создавать комиты изолированно от остальных веток. В дальнейшем можно между этими ветками переключатся сохраняя в каждой ветке тот стейт до которого разработка дошла. При создании репозитория, в нём автоматически создаётся основная ветка - master, которая может быть использована для фиксации изменений. Это достаточно, чтобы создавать новые коммиты и вести работу, но с ростом размера проекта и команды это становится не удобно. Какой именно подход по использованию веток выбрать зависит от размеров команды, проекта зависит и принятого workflow зависит.

Этап 1. В процессе разработки появится необходимость в ревью, CI и остальном. Чтобы реализовать накую возможность, нужно создавать отдельную ветку, чтобы от неё создавать pull request. В этот момент появляется необходимость в feature-ветках. Это такие ветки, которые создаются под написание одной новой фичи, одного изменений etc. Их время жизни заканчивается после мёрджа ветки в master. Такие ветки можно называть `feat/your-feature-name`. Аналогично можно сказать про фиксы.

Этап 2. По мере усложнения продукта и увеличения размера цикла разработки, появляется необходимость иметь стабильную ветку, с которой можно взять рабочую версию. Проблема в том, что изменения, которые вливаются с feature-веток, могут быть недостаточно протестированы. В такой ситуации имеет смысл выделить dev-ветку. Эта ветка будет использоваться во время разработки, в неё будут вливаться изменения. После того, как все нужные изменения влиты и протестированы, ветка dev вливается в мастер.

Этап 3. Есть сценарии, которые не вписываются в модель с master + dev ветками. Самый частых из них - это необходимость загрузить hotfix в master. Но если делать это через dev ветку, то могут попасть остальные изменения, которые нужно детально тестировать. Чтобы сократить время и исправить проблему ASAP вводят hotfix ветки, которые после верификации вливаются в master и dev ветки.

Этап 4. Если в проекте много разработчиков и они параллельно ведут работают над проектом, то в какой-то момент часть из них будет занята стабилизацией ветки dev и её подготовкой к слиянию. В то же время остальные будут продолжать разработку и вносить новые изменения в dev, тем самым усложняя работу первой группе. Чтобы избежать такой проблемы, имеет смысл выделить ветку release. Как только работы над веткой dev заканчиваются, от последнего комита создаётся ветка release и в ней происходит закрытие проблем и багой, которые мешают влить ветку dev в ветку master. Как только все проблемы устранены, ветка release вливается в master и в dev (он за время существования ветки release там могли появиться коммиты).

## Base branch merge

Рассмотрим частую ситуацию при разработке и использованием веток. В проекте существовала ветка master, от неё отбранчили две feature-ветки - feature-a и feature-b, в них начали создаваться коммиты. После этого ветку feature-a доделали и вмёрджили в master, а в ветке feature-b появилась необходимость использовать изменения из feature-a. Есть два варианта решения проблемы:

- rebase  - перенести изменения feature-b на последний коммит мастера после мёрджа
- merge master to feature-b - смёрджить изменения из ветки master в ветку, где этих изменений не хватает. Это не соответствует обычному workflow мёрджа, но такой мёрдж позволяет синхронизировать feature-ветку с её base-веткой.

## Pull request

Pull request - это механизм, который выходит за рамки git, но он есть во всех сервисах управления репозиториями (GitHub, Azure DevOps). Pull request - это запрос на влитие одной ветки в другую. Хорошим тоном является закрытие возможности делать push коммитов в master и единственным способом залить туда коммиты - это создание pull request'а. Pull request - это этап между созданием коммита и его попадания в мастер ветку, который позволяет задавать правила для merge операции:

- Возможность сконфигурировать GitHub Action и запускать билд и проверку всех тестов
- Возможность сконфигурировать GitHub Action и запускать анализатор кода (например, SonarCloud)
- Возможность повесить требование на обязательное ревью перед merge

Если эти требования не соблюдаются, то GitHub не будет давать возможности выполнить pull request merge.

## Conflict

При параллельной работе с репозиторием может оказаться ситуация, когда два pull request'а меняют одинаковые строчки. Система контроля версий не может за пользователя решить, какую именно строчку нужно в итоге загрузить и называет такую ситуацию merge conflict. Если работать с репозиторием через pull request, то информация о конфликте появится в самом PR и будет заблокирована возможность выполнить merge. Решением этой проблемы является ручной резолв конфликтов:

1. Открыть локально репозиторий, сделать pull ветки от своего PR'а и ветки master
2. Выполнить checkout ветки от PR
3. Выполнить merge ветки master в текущую ветку
4. Получить сообщение о конфликте и вручную выбрать какие изменения с каких веток должны попасть
5. Закомитить изменения, которые были внесены во время мёрджа
6. Выполнить push своей ветки, чтобы обновления попали в PR

После этих действий ветка PR'а и master будут синхронизированы и конфликтов не будет.