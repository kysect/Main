# Branching

Ветки в git - это специальным образом сохранённые ссылки на определённый коммит.

Ветки в git позволяют создавать комиты изолированно от остальных веток. В дальнейшем можно между этими ветками переключатся сохраняя в каждой ветке тот стейт до которого разработка дошла. При создании репозитория, в нём автоматически создаётся основная ветка - master, которая может быть использована для фиксации изменений. Это достаточно, чтобы создавать новые коммиты и вести работу, но с ростом размера проекта и команды это становится не удобно. Какой именно подход по использованию веток выбрать зависит от размеров команды, проекта зависит и принятого workflow зависит.

Этап 1. В процессе разработки появится необходимость в ревью, CI и остальном. Чтобы реализовать накую возможность, нужно создавать отдельную ветку, чтобы от неё создавать pull request. В этот момент появляется необходимость в feature-ветках. Это такие ветки, которые создаются под написание одной новой фичи, одного изменений etc. Их время жизни заканчивается после мёрджа ветки в master. Такие ветки можно называть `feat/your-feature-name`. Аналогично можно сказать про фиксы.

Этап 2. По мере усложнения продукта и увеличения размера цикла разработки, появляется необходимость иметь стабильную ветку, с которой можно взять рабочую версию. Проблема в том, что изменения, которые вливаются с feature-веток, могут быть недостаточно протестированы. В такой ситуации имеет смысл выделить dev-ветку. Эта ветка будет использоваться во время разработки, в неё будут вливаться изменения. После того, как все нужные изменения влиты и протестированы, ветка dev вливается в мастер.

Этап 3. Есть сценарии, которые не вписываются в модель с master + dev ветками. Самый частых из них - это необходимость загрузить hotfix в master. Но если делать это через dev ветку, то могут попасть остальные изменения, которые нужно детально тестировать. Чтобы сократить время и исправить проблему ASAP вводят hotfix ветки, которые после верификации вливаются в master и dev ветки.

Этап 4. Если в проекте много разработчиков и они параллельно ведут работают над проектом, то в какой-то момент часть из них будет занята стабилизацией ветки dev и её подготовкой к слиянию. В то же время остальные будут продолжать разработку и вносить новые изменения в dev, тем самым усложняя работу первой группе. Чтобы избежать такой проблемы, имеет смысл выделить ветку release. Как только работы над веткой dev заканчиваются, от последнего комита создаётся ветка release и в ней происходит закрытие проблем и багой, которые мешают влить ветку dev в ветку master. Как только все проблемы устранены, ветка release вливается в master и в dev (он за время существования ветки release там могли появиться коммиты).

## Base branch merge

Рассмотрим частую ситуацию при разработке и использованием веток. В проекте существовала ветка master, от неё отбранчили две feature-ветки - feature-a и feature-b, в них начали создаваться коммиты. После этого ветку feature-a доделали и вмёрджили в master, а в ветке feature-b появилась необходимость использовать изменения из feature-a. Есть два варианта решения проблемы:

- rebase  - перенести изменения feature-b на последний коммит мастера после мёрджа
- merge master to feature-b - смёрджить изменения из ветки master в ветку, где этих изменений не хватает. Это не соответствует обычному workflow мёрджа, но такой мёрдж позволяет синхронизировать feature-ветку с её base-веткой.

## Pull request

Pull request - это механизм, который выходит за рамки git, но он есть во всех сервисах управления репозиториями (GitHub, Azure DevOps). Pull request - это запрос на влитие одной ветки в другую. Хорошим тоном является закрытие возможности делать push коммитов в master и единственным способом залить туда коммиты - это создание pull request'а. Pull request - это этап между созданием коммита и его попадания в мастер ветку, который позволяет задавать правила для merge операции:

- Возможность сконфигурировать GitHub Action и запускать билд и проверку всех тестов
- Возможность сконфигурировать GitHub Action и запускать анализатор кода (например, SonarCloud)
- Возможность повесить требование на обязательное ревью перед merge

Если эти требования не соблюдаются, то GitHub не будет давать возможности выполнить pull request merge.

## Conflict

При параллельной работе с репозиторием может оказаться ситуация, когда два pull request'а меняют одинаковые строчки. Система контроля версий не может за пользователя решить, какую именно строчку нужно в итоге загрузить и называет такую ситуацию merge conflict. Если работать с репозиторием через pull request, то информация о конфликте появится в самом PR и будет заблокирована возможность выполнить merge. Решением этой проблемы является ручной резолв конфликтов:

1. Открыть локально репозиторий, сделать pull ветки от своего PR'а и ветки master
2. Выполнить checkout ветки от PR
3. Выполнить merge ветки master в текущую ветку
4. Получить сообщение о конфликте и вручную выбрать какие изменения с каких веток должны попасть
5. Закомитить изменения, которые были внесены во время мёрджа
6. Выполнить push своей ветки, чтобы обновления попали в PR

После этих действий ветка PR'а и master будут синхронизированы и конфликтов не будет.

## Коммиты и ветки

Чтобы лучше использовать git, стоит чуть глубже разобраться в том, что именно за действия происходит во время выполнения git операций.

Во время создания репозитория создаётся первый коммит. Первый созданный коммит содержит только снимок и набор метаданных. Также создаётся master ветка, которая на этот коммит ссылается.

Каждый следующий коммит создаётся относительно прошлого коммита. В созданном новом коммите сохраняется ссылка на прошлый коммит, он считается родительским. При создании коммита также модифицируется и ветка. Коммит создаётся в активной ветке, относительно последнего коммита этой ветки. После создания нового коммита ветка начнёт ссылаться на новый созданный коммит - происходит перенос ссылки на новый коммит.

Выполнение мёрджа также создаёт коммит. Если выполняется мёрдж ветки A в ветку B, то в ветке B создаётся новый коммит у которого будут записано два родительских коммита.

Что делать, если коммит был создан не в той ветке? Например, пользователь забыл создать feature-ветку и создался коммит в ветке master. В первую очередь, строит вспомнить, что ветки - это ссылки на коммиты. На созданном комите можно создать новую ветку (т.е. ссылку). После создания новой ветки на созданном коммите остаётся проблема того, что ветка master также ссылается на этот коммит. Это решается тем, что в гите есть возможность двигать ветки между коммитами. Они всё ещё являются просто ссылками. Можно выполнить hard reset ветки мастер на прошлый коммит и тем самым откатить ветку назад. Порядок действий:

1. Осознать проблему
2. Создать ветку на последнем коммите
3. Выполнить checkout на ветку master
4. Выполнить reset мастера на прошлый коммит
5. Вернуться обратно на feature-ветку

Но что же делать, если коммит уже запушился в remote repository? После выполнения reset remote ветка не будет обновлена, её нужно запушить. Но стоит понимать, что push удаления коммита - это потенциальное нарушение дерева. GitHub будет предупреждать, что так делать не стоит, что выполнить это можно только  помощью force push.