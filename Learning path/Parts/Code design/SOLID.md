# SOLID

## **S**ingle Responsibility Principle (Принцип единственной обязанности)

SRP - Каждый модуль (класс) должен быть ответственен за единственную задачу.
Он может иметь несколько методов, но они должны использоваться лишь для решения общей задачи.

```csharp
public interface ILogger
{
    void Info(string info);
    void Debug(string info);
    void Error(string message, Exception ex);
}

public class Logger : ILogger
{
    public Logger()
    {
        // Code for initialization 
        // that is creating the Log file with necesssary details
    }
    public void Info(string info)
    {
        // ...
    }
    public void Debug(string info)
    {
        // ...
    }
    public void Error(string message, Exception ex)
    {
        // ...
    }
}
```

### **O**pen/Closed Principle (Принцип открытости/закрытости)

- Если есть зависимость от внешних сущностей, то их нужно прокидывать аргументами.
- Делать расширяемость по-дефолту, а не когда нужно. Если это бекап репо, то путь всегда делать аргументом
- EF, завязка на определённой базе

**Сущности программы должны быть открыты для расширения, но закрыты для изменения**.

Суть этого принципа состоит в том, что система должна быть построена таким образом, что все ее последующие изменения должны быть реализованы с помощью добавления нового кода, а не изменения уже существующего.

### **L**iskov Substitution Principle (Принцип подстановки Лисков)

- Не использовать наследование для переиспользования логики. Если объект наследуется, то справедливым должно быть высказывание, что производный объект является базовым (см. LSP).

```csharp
Если для каждого объекта o1 типа S существует объект o2 типа T, такой,
что для любой программы P, определенной в терминах T,
поведение P не изменяется при замене o2 на o1, то S является подтипом T.
```

Иными словами класс S может считаться подклассом T, если замена объектов T на объекты S не приведет к изменению работы программы.

Если упростить, то принцип говорит о том, что должна быть возможность вместо базового типа подставить любой его подтип.

Проблему, с который связан принцип Лисков, наглядно можно продемонстрировать на примере двух классов Прямоугольника и Квадрата.

```csharp
class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
     
    public int GetArea() => Width * Height;
}
 
class Square : Rectangle
{
    public override int Width
    {
        get => base.Width; 
        set
        {
            base.Width = value;
            base.Height = value;
        }
    }
 
    public override int Height
    {
        get => base.Height;
 
        set
        {
            base.Height = value;
            base.Width = value;
        }
    }
}

void ProcessRectangle(Rectangle rect)
{
    rect.Width = 20;
    rect.Height = 10;
    var area = rect.GetArea();
    ...
}
```

Как правило, квадрат представляют как частный случай прямоугольника - те же прямые углы, четыре стороны, только ширина обязательно равна высоте. Поэтому в классе Квадрат у одного свойства устанавливаются сразу и ширина, и высота.

На первый взгляд вроде все правильно, классы предельно простые, всего два свойства, и, казалось бы, сложно где-то ошибиться.

Но проблема заключается в том, что производный класс Square не ведет себя как базовый класс Rectangle, и поэтому его не следует наследовать от данного базового класса. В этом и есть практический смысл принципа Лисков. Производный класс, который может делать меньше, чем базовый, обычно нельзя подставить вместо базового, и поэтому он нарушает принцип подстановки Лисков.

// Рассказать что не нужно хакать через проверку типов и upcast'ы.

### **I**nterface Segregation Principle (Принцип разделения интерфейсов)

- История про логгер и имплементацию 15 методов

"Не вынуждайте пользователей реализовывать или зависеть от того, чего им не требуется"

При нарушении этого принципа клиент, использующий некоторый интерфейс со всеми его методами, зависит от методов, которыми не пользуется, и поэтому оказывается восприимчив к изменениям в этих методах. В итоге мы приходим к жесткой зависимости между различными частями интерфейса, которые могут быть не связаны при его реализации.

В этом случае интерфейс класса разделяется на отдельные части, которые составляют раздельные интерфейсы. Затем эти интерфейсы независимо друг от друга могут применяться и изменяться. В итоге применение принципа разделения интерфейсов делает систему слабосвязанной, и тем самым ее легче модифицировать и обновлять.

Пример из реальной жизни:

У вас может быть МФУ для печати, сканирования и отправки факсов, три в одном, всё в одном устройстве. А могут быть три отдельных устройства.

Как не нужно:

```csharp
interface IDevice
{
    void Print(...);
    void Fax(...);
    void Scan(...);
}
```

Как правильно:

```csharp
interface IPrinter
{
	void Print(...);
}

interface IFax
{
	void Fax(...);
}

interface IScanner
{
	void Scan(...);
}

class MultifunctionalDevice : IPrinter, IFax, IScanner 
{
    // Implements...
    public void Print(...);
    public void Fax(...);
    public void Scan(...);
}
```

## Dependency Inversion Principle (Принцип инверсии зависимостей)

- inversion of control

Принцип инверсии зависимости (Dependency Inversion Principle; DIP) утверждает, что наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, а не на конкретные реализации.

Очевидно, что принять эту идею за правило практически невозможно, потому что программные системы должны зависеть от множества конкретных  особенностей. Например, String — это конкретный класс и его невозможно сделать абстрактным.
С другой стороны, класс String очень стабилен. Изменения в этот класс вносятся крайне редко и жестко контролируются. Программистам и архитекторам не приходится беспокоиться о частых и непредсказуемых изменениях в String.

Мы должны избегать зависимости от неустойчивых конкретных элементов системы. То есть от модулей, которые продолжают активно разрабатываться и претерпевают частые изменения.
