# Type design

## Тип - как способ вводить абстракции

- Абстракции != интерфейсы
- Текучие абстракции (IsPhysicalStorageAvailable в репо)

## Код, выдерживающий проверку компилятором

- Компайл тайм валидация

## Проектирование типов, Категории типов

- Стабильность типа - Примитивы\Value types\Объекты со стабильными интерфейсами\боль

- Примитивы
- Сущности
- Value Object
- Service\Helper\etc.

## Value objects

Значенме можно считать Value object, если:

- Оно измеряет, оценивает или описывает объект предметной области
- Его можно считать неизменяемым
- Оно поделирует нечто концептуально целосностное, объединяет связанные атрибуты
- Его можно сравнить с другими объектами значений
- Методы связанные с VO должны быть без побочных эффектов

Обычно, когда говорят про проектирование типов - подразумевают какие-то сложные классы и их связи. Но не часто говорят про то, как можно упростить код за счет типизированных оберток. Например, в шарпе пришли к тому, что время хранить int milliseconds - не хорошо и обернули в TimeSpan. По аналогии можно в ввести структуру MemorySize вместо того, чтобы в коде хранить информацию о размерах файлов в int'ах. Оказывается, что это сильно улучшает объектную модель, делает сигнатуры понятнее, на уровне компилятора защищает от лишнего деления на 1024 при конвертации в мегабайты

## Сущности

- Идентификатор - как ключевой элемент сущностей. Неизменяемость идентификатора
  - Идентификаторы задаваемые пользователем
  - Идентификатор генерируемый приложением
  - Идентификатор генерируемый хранилищем данных
  - Идентификатор из другого контекста
- Характеристика изменчивости

Привычные практики, показал примеры, когда id - это инт и когда guid, плюсы минусы. Рассказать как генерировать это id, показать на примере баз данных, как ответственность по генерации можно отдавать вне программы.

Что объект после создания всегда должен находится в "правильном" состоянии, что не должно быть ситуации, когда все поля публичные и их может пользователь неправильно назначить или наоборот не инициализировать.Стабильность типа. Иммутабельность типов уменьшает вероятность проблем с типом. Например, та же структура MemorySize будет отлично работать если у нее не будет сеттеров (а просто одно int поле внутри храниться) и они будет пересоздаваться. И наоборот, если у класса много изменяемых полей, то нужно в каждый момент времени быть уверенным, что изменение не сломает что-то.

Конструтирорвание типа, проверка корректности атрибутов и свойств - валидация. Про валидацию очень хорошо написано в книге [D2] (глава 5, сущности. Выявление сущностей. Проверка корректности)

## Stateful, stateless

## Mutable, immutable

## Анемичная модель предметной области [S1]

1. Структуры данных и операции над ними (поведение) разделены. Чаще всего структуры данных называют «сущностями», а поведение — «сервисами».
2. Структура программного код отражает скорее паттерны и фреймворки.
3. Бизнес-правила либо невозможно понять, путем изучения кода, либо это дается с большим трудом.
4. И наконец, инварианты не соблюдаются, а зачастую даже отрицается такая необходимость или возможность

Примеры: типичные реализации с применением Repository + Services. Например, вот по этой статье можено легко собрать систему с анемической моделью - [https://www.forevolve.com/en/articles/2017/08/11/design-patterns-web-api-service-and-repository-part-1/](https://www.forevolve.com/en/articles/2017/08/11/design-patterns-web-api-service-and-repository-part-1/)

## Насыщенная модель предметной области [A2]

1. Структура данных и поведение совмещены в одних и тех же классах.
2. Структура программного кода отражает структуру домена, т.е. классы, относящиеся к бизнес-логике должны называться «касса», «проводка», «платежная ведомость», а не «сервис», «репозиторий» или «прокси».
3. Самое важное, соблюдаются инварианты объектов, т.е. их состояние непротиворечиво.

Примеры в статье [A2] и [D1]. В D1 хорошое сравнение и примеры перехода из одной модели в другую. Также хорошо описано про проектирование сущностей в [D2] (глава 5. Сущности. Выявление сущностей и свойств)

## Sources

- [S1] - [http://samolisov.blogspot.com/2012/10/anemic-domain-model.html](http://samolisov.blogspot.com/2012/10/anemic-domain-model.html)
- [F1] - [https://martinfowler.com/eaaCatalog/index.html](https://martinfowler.com/eaaCatalog/index.html)
- [A1] - [https://habr.com/ru/post/259829/](https://habr.com/ru/post/259829/)
- [A2] - [https://habr.com/ru/company/jugru/blog/503868/](https://habr.com/ru/company/jugru/blog/503868/) (там оч классный доклад в открытом доступе + преза к нему - [https://drive.google.com/file/d/1ZvDGlXCNL3JIFi2LaYiYye-d03AefyeV/view](https://drive.google.com/file/d/1ZvDGlXCNL3JIFi2LaYiYye-d03AefyeV/view))
- [D1] - [https://altkomsoftware.pl/en/blog/create-better-code-using-domain-driven-design/](https://altkomsoftware.pl/en/blog/create-better-code-using-domain-driven-design/)
- [D2] - Реализация методов предметно-ориентированого проектирования, Вон Вернон
