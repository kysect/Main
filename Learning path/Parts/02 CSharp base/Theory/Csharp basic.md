# C# basic

## Енамы как ограниченное множество значений

Енамы - это отдельная категория типов в C#. Их можно воспринимать как ограниченное множество значений. Так например, для описания дней недели есть встроенный DayOfWeek. Имея ограниченный набор значений, по ним можно итерироваться - написать foreach по енаму с днями недели и вывести их все. При этом, если бы для обозначения дней использовались бы int значения, то было бы не ясно, сколько их т.к. множество допустимых значений около 4кк. Несмотря на то, что для енамов явно задаются значений и имеется ограниченный набор значений, среда выполнения не валидирует ситуацию, когда в енам сетится числовое значение, которому не соответствует ничего в енаме.

Логику енамов можно расширить атрибутом [Flags], который превращает его в битовую маску, для него начинают работать оператор | и метод `HasFlag`. Это полезно когда нужно совмещать несколько флагов. Например, если нам нужно хранить рабочие дни магазина:

```csharp
var workingHours = SelectedDayOfWeek.Monday | SelectedDayOfWeek.Friday;
return workingHours.HasFlag(SelectedDayOfWeek.Sunday);
```

Одна из неприятных особенностей енамов - не возможность расширить данные методами. Как мы помним из ООП, один из постулатов в том, чтобы данные и методы были вместе. Для енамов единственным способом этого достичь являются экстеншен методы:

```csharp
public enum DayOfWeek
{
    Monday,
    ...
}

public static class DayOfWeekExtensions
{
    public static string ToRuString(this DayOfWeek value)
    {
        switch (value)
        {
            case Monday:
                return "Понедельник";
            ...
        }
    }
}

```

## Immutable types

Строки - это особый тип в dotnet. Одна из его особенность - это иммутабельность. Методы типа String не меняют сам экземпляр, а создают изменённую копию. Так например, вызов метода Replace у строки создаст новую строку, где будут символы заменены. Такой подход позволяет быть уверенным, что объект не будет изменяться и на него можно полагаться. Но с другими типами такой уверенности нет. Например, если мы работает с объектом User у которого есть First и Last name, то сложно сказать в какой момент работы приложения кто-то решит в этот экземпляр засетить значение.

Ещё сложнее всё с мутабельностью в подсчёте хешкода. Вспомним, как работает хеш-сет. Чтобы положить элемент в хеш-сет, нужно посчитать его хеш-код и положить в нужную ячейку внутреннего массива. Когда нам нужно будет проверить находится ли объект в хеш-сете, то мы считаем его хеш-сет и смотрим на нужную ячейку. Но проблема в том, что между этими действиями объект изменился, то мы уже не найдём его в хеш-сете ввиду того, что его значение изменилось, а значит и хеш-сет. Это причина по которой анализаторы очень настоятельно не рекомендуют в методах подсчёта хеш-сета использовать иммутабельные данные.

Но как же быть? Ответ простой - делать иммутабельные экземпляры. Как строки. В C# такое поведение могут предоставлять рекорды. Рекорд - это тип альтернативный классу, который имеет особое поведение. Он описывается списком своих основных свойств. Для рекорда по этим свойствам автоматически создаётся конструктор, операторы сравнения, подсчёта хеш-код. И поведение такое же как и у строк - копирование при изменении. Вместо того, чтобы изменить пользователя, можно написать код `var newUser = user with {FirstName = "Another"}`.

Но рекорды решают проблему только иммутабельности значений полей, но они не могут гарантировать иммутабельность состояния поля. Если у рекорда будет одним из полей другой мутабельный класс, то он может изменяться и всё продолжит рушится. Особенно грустно всё обстоит с коллекциями. Довольно часто можно заметить тип, у которого есть поле типа List. И если оно публичное, то это значит, что любой другой тип из-вне может его изменить и это будет очень сложно отследить. Для коллекций тоже есть иммутабельные аналоги. Это иммутабельные коллекции, которые также копируются при изменении. С той лишь разницей, что делают они это чуть более умно для экономии памяти. Если мы удалили с коллекции первый элемент, но не обязательно копировать весь лист, можно просто создать указатель на второй элемент при условии, что структура хранения листа - это линкед лист.

## Disposable

### Управление освобождаемыми ресурсами

В языках, которые имеют GC, можно не думать о том, как и когда будет освобождаться память и удаляться объект. Но работает это не для всех объектов. Некоторые объекты ассоциированы с другими объектами вне кода. Например, файловые потоки. В C# можно открыть поток чтения из файла и работать с ним. При этом, сам объект потока будет удерживать файловый дескриптор. Он будет не давать другим процессам или потокам работать с файлом. Если такой объект создать и не освободить дескриптор, то не будет возможности с файлом работать, пока где-то за кулисами не будет дескриптор освобождён (если будет!).

Для того, чтобы работать с подобными освобождающимися ресурсами, в C# введён интерфейс IDisposable, который имплементять типа, которые имеют какую-то логику освобождения. Интерфейс содержит один метод Dispose. Для этого интерфейса есть отдельный синтаксический сахар - `using`. Это связано с тем, что помимо вызова метода, нужно гарантировать, что вызываться он будет всегда, особенно при возникновении ошибок.

```csharp
void F()
{
    IDisposable value;
    try
    {
        value = new Resourse();
        value.Do();
    }
    finally
    {
        value?.Dispose();
    }
}

void F2(IDisposable value)
{
    using (IDisposable value = new Resourse())
        value.Do();
}
```

Тут и далее будем под ресурсами (для упрощения) называть экземпляры IDisposable, а под очисткой/освобождением - вызов метода Dispose. Помимо уменьшения количества кода, `using` уменьшает шанс, что пользователь забудет вызвать метод Dispose или потеряет его при копировании кода. Также, ввиду единого интерфейса для освобождаемых ресурсов, существуют встроенные анализаторы кода, которые могу находить участки кода, где ресурсы не освобождаются.

### Кто отвечает за ресурс

Частая проблема управления ресурсами состоит в том, что не очевидно, кто должен ресурсы освобождать. Например, когда мы создаём объект, который реализует IDisposable, то оборачиваем его в using – всё просто. Но что, если мы передаём такой экземпляр внутрь какого-то метода? Можем ли мы гарантировать, что внутри метода не будет закеширован этот объект, который впоследствии будет задиспоужен, но при этом сохранён где-то в кеше, что означает вероятность обращения к нему – уже задиспоуженному объекту? Или если такой объект будет задиспоужен в методе, то получится так, что мы дважды будем его диспоузить (внутри метода и через использование конструкции using)! Рассмотрим самые частые ситуации и вопросы.

Кто должен освобождать ресурсы? Однозначно ответить сложно. Усложняет ситуацию то, что наш код может использовать другие решения, которые имеют свои представления о работе с ресурсами. Но в ситуации, когда всем кодом можно управлять, применяют подход, когда ресурсы освобождает тот, кто их получил. Очень способствует этому синтаксис using, он форсит нас к тому, чтобы сразу объявить и создание, и освобождение.

А если ресурс передаётся аргументом, то что с ним делать? Его можно использовать, но его не стоит диспоузить, т.к. вызывающему коду будет не очевидно, почему его объект уже не может быть использован. Если при этом ресурс необходимо сохранить внутри класса, который получает ресурс, то такой класс должен транзитивно становиться IDisposable. Это значит, что любой класс, который содержит в качестве полей IDisposable, должен диспоузится.

Значит, если я не буду вызывать .Dispose на ресурсе, который прокидывается аргументом, то никаких проблем не возникнет? До тех пор, пока не будет вызвано освобождение неявно. Одна из таких ловушек описана чуть выше в качестве совета. Если мы создадим класс, передадим ему ресурс, а потом его задиспоузим, то ему очень захочется задиспоузить его. Есть ли уверенность, что `using (var reader = new StreamReader(stream))` не будет вызывать stream.Dispose?

А что делать с тем, что Dispose вызывается дважды? Краткий ответ - ничего, страдать. Решить проблему довольно сложно, т.к. всё завязывается на детали реализации кода другими разработчиками. Единственный хороший момент – это рекомендации Майкрософта по имплементации паттерна Disposable. В них указано, что метод Dispose нужно реализовывать так, чтобы повторный вызов ничего не ломал. Из грустных моментов – это работает не всегда: даже стандартные TcpClient бросают ошибки при повторном вызове Dispose.

Нужно ещё отметить очень очевидный момент. Dispose – это метод экземпляра и вызывается на нём. Из этого следует очень неприятный вывод: "нельзя вызвать Dispose, если нет объекта". Представим ситуацию, что в конструкторе создаётся два экземпляра класса Stream и сохраняются в поля. Разумеется, что мы помним про то, что их нужно освобождать и в методе Dispose будем это делать. А теперь представим, что мы создали первый экземпляр, а на создании второго упали с ошибкой. Вызывается ли освобождение созданного экземпляра? Нет. Мы упали в конструкторе, не успели создать экземпляр, а значит не можем вызывать метод Dispose. В этой ситуации using не сильно то поможет и нужно контролировать выполнение с помощью try-catch и соответствующе обработать такую ситуацию.
