# C# basic

> TODO: I2 Обдумать что ещё сюда добавить

## Енамы как ограниченное множество значений

Енамы - это отдельная категория типов в C#. Их можно воспринимать как ограниченное множество значений. Так например, для описания дней недели есть встроенный DayOfWeek. Имея ограниченный набор значений, по ним можно итерироваться - написать foreach по енаму с днями недели и вывести их все. При этом, если бы для обозначения дней использовались бы int значения, то было бы не ясно, сколько их т.к. множество допустимых значений около 4кк. Несмотря на то, что для енамов явно задаются значений и имеется ограниченный набор значений, среда выполнения не валидирует ситуацию, когда в енам сетится числовое значение, которому не соответствует ничего в енаме.

Логику енамов можно расширить атрибутом [Flags], который превращает его в битовую маску, для него начинают работать оператор | и метод `HasFlag`. Это полезно когда нужно совмещать несколько флагов. Например, если нам нужно хранить рабочие дни магазина:

```csharp
var workingHours = SelectedDayOfWeek.Monday | SelectedDayOfWeek.Friday;
return workingHours.HasFlag(SelectedDayOfWeek.Sunday);
```

Одна из неприятных особенностей енамов - не возможность расширить данные методами. Как мы помним из ООП, один из постулатов в том, чтобы данные и методы были вместе. Для енамов единственным способом этого достичь являются экстеншен методы:

```csharp
public enum DayOfWeek
{
    Monday,
    ...
}

public static class DayOfWeekExtensions
{
    public static string ToRuString(this DayOfWeek value)
    {
        switch (value)
        {
            case Monday:
                return "Понедельник";
            ...
        }
    }
}

```

## Immutable types

Строки - это особый тип в dotnet. Одна из его особенность - это иммутабельность. Методы типа String не меняют сам экземпляр, а создают изменённую копию. Так например, вызов метода Replace у строки создаст новую строку, где будут символы заменены. Такой подход позволяет быть уверенным, что объект не будет изменяться и на него можно полагаться. Но с другими типами такой уверенности нет. Например, если мы работает с объектом User у которого есть First и Last name, то сложно сказать в какой момент работы приложения кто-то решит в этот экземпляр засетить значение.

Ещё сложнее всё с мутабельностью в подсчёте хешкода. Вспомним, как работает хеш-сет. Чтобы положить элемент в хеш-сет, нужно посчитать его хеш-код и положить в нужную ячейку внутреннего массива. Когда нам нужно будет проверить находится ли объект в хеш-сете, то мы считаем его хеш-сет и смотрим на нужную ячейку. Но проблема в том, что между этими действиями объект изменился, то мы уже не найдём его в хеш-сете ввиду того, что его значение изменилось, а значит и хеш-сет. Это причина по которой анализаторы очень настоятельно не рекомендуют в методах подсчёта хеш-сета использовать иммутабельные данные.

Но как же быть? Ответ простой - делать иммутабельные экземпляры. Как строки. В C# такое поведение могут предоставлять рекорды. Рекорд - это тип альтернативный классу, который имеет особое поведение. Он описывается списком своих основных свойств. Для рекорда по этим свойствам автоматически создаётся конструктор, операторы сравнения, подсчёта хеш-код. И поведение такое же как и у строк - копирование при изменении. Вместо того, чтобы изменить пользователя, можно написать код `var newUser = user with {FirstName = "Another"}`.

Но рекорды решают проблему только иммутабельности значений полей, но они не могут гарантировать иммутабельность состояния поля. Если у рекорда будет одним из полей другой мутабельный класс, то он может изменяться и всё продолжит рушится. Особенно грустно всё обстоит с коллекциями. Довольно часто можно заметить тип, у которого есть поле типа List. И если оно публичное, то это значит, что любой другой тип из-вне может его изменить и это будет очень сложно отследить. Для коллекций тоже есть иммутабельные аналоги. Это иммутабельные коллекции, которые также копируются при изменении. С той лишь разницей, что делают они это чуть более умно для экономии памяти. Если мы удалили с коллекции первый элемент, но не обязательно копировать весь лист, можно просто создать указатель на второй элемент при условии, что структура хранения листа - это линкед лист.
