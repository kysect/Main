# Genetics

## Func, Action

В базовой библиотеке поверх дженериков созданы специализированные делегаты. Делегаты - это управляемые ссылки на методы. А тип Func<> - это специальная обёртка, которая позволяет эти делегаты сетить в качестве переменных или аргументов: `Func<int, int> sqr = (x) => x * x` (переменная sqr содержит ссылку на функцию, которая принимает аргумент и возвращает квадрат). Подобные лямбды очень часто используются в LINQ, чтобы описать простое действие (фильтрацию, определение критерия для сортировки). 

## Дженерик коллекции

- IEnumerable, как работает, почему этого достаточно и почему не стоит использовать

> TODO: I2

В системной библиотеке довольно много типов для коллекций и много интерфейсов. Есть ряд довольно очевидных и специфичных коллекций - Dictionary, Stack, ImmutableHashSet. Но есть те, которые вопросы всё же вызывают - Array и List. Эти две коллекции довольно часто используются. массив является одним из первых вещей, которые изучают вместе с языков, а также фундаментальная вещь в API базовой библиотеки (получение данных с потока, сплит строки). Лист в свою очередь становится первой коллекцией, которая приходит на замену массиву, когда пользователю нужно добавлять элементы в массив. И понемногу становится чуть ли не единственной коллекцией. К счастью для многих, в базовой библиотеке есть методу ToArray и ToList, которые дают возможность перевести первое во второе и наоборот (если не учитывать накладные расходы на полное копирование коллекции).

В такой ситуации единственным правильным выходом будет ~~запретить массивы~~ использовать их общий интерфейс в публичных интерфейсах. Например, вместо `List<Item> Reorder(Item[] items)` использовать `IReadOnlyCollection<Item> Reorder(IReadOnlyCollection<Item> items)`. Это позволит с одной стороны принимать все те же данные, а с другой - форсить остальной код к работе с абстракцией, а не конкретным типом. IReadOnlyCollection в данном случае был выбран ввиду того, что ICollection - это самый предпочтительный общий предок. Можно взять самый базовый IEnumerable, но он концептуально описывает перечисление, которое не обязательно является конечным, не обязательно является коллекцией и может перевычисляться при обращении. А ICollection описывает коллекцию элементов, которые можно использовать и на которых даже определён упорядоченный доступ по индексу. ReadOnly в данном случа лишь скрывает лишние возможности по модификации коллекции.

## LINQ - код без for'ов

LINQ - это набор экстеншен методов для работы с коллекциями. У LINQ есть альтернативный способ записи, где вместо экстеншен методов используется специальный язык запросов похожий на SQL. Он имеет место быть, но в большинстве случаев выглядит не очень привычно для C# разработчиков. Там содержится ряд часто используемых методов, которые заменяют большую часть for/foreach выражений:

- Select(x => ToY(x)) - метод, который каждый элемент коллекции преобразует в другой
- Where(x => Acceptable(x)) - метод, который по предикату фильтрует и возвращает только те элементы, которые соответствуют предикату
- OrderBy(x => x.Priority) - метод, который сортирует элементы по заданному правилу
- First/FirstOrDefault - методы, которые возвращают элемент из коллекции. Если элемента нет то либо бросает ошибку, либо возвращает default для OrDefault методов
- ToList - преобразует в лист обрабатываемую коллекцию
- ToDictionary, GroupBy, etc...

Эти экстеншен методы написаны для IEnumerable<T>, многие возвращают его же (не все). Это даёт возможность выстраивать fluent-цепочку выполнений:

```csharp
var output = input
    .Select(x => x + 3)
    .Where(x => x % 2 != 0)
    .OrderBy(x => x)
    .Take(10)
    .ToList();
```

При этом, каждый результат выполнения - это новая коллекция. Такой код не изменит коллекцию:

```csharp
List<string> students = ...
students.ToList().Add("new student");
```

## Sources

- https://docs.microsoft.com/en-us/dotnet/csharp/linq/
