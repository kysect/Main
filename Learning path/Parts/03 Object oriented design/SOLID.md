# SOLID

## Single Responsibility Principle (Принцип единственной обязанности)

SRP - Каждый модуль (класс) должен быть ответственен за единственную задачу.
Он может иметь несколько методов, но они должны использоваться лишь для решения общей задачи.

```csharp
public interface ILogger
{
    void Info(string info);
    void Debug(string info);
    void Error(string message, Exception ex);
}

public class Logger : ILogger
{
    public Logger()
    {
        // Code for initialization 
        // that is creating the Log file with necesssary details
    }
    public void Info(string info)
    {
        // ...
    }
    public void Debug(string info)
    {
        // ...
    }
    public void Error(string message, Exception ex)
    {
        // ...
    }
}
```

## Open/Closed Principle (Принцип открытости/закрытости)

Сущности программы должны быть открыты для расширения, но закрыты для изменения. Суть этого принципа состоит в том, что система должна быть построена таким образом, что все ее последующие изменения должны быть реализованы с помощью добавления нового кода, а не изменения уже существующего. Под этим подразумевается наличие точек расширения, где вместо явных типов используются контракты, которые могут быть реализованы в соответствии с тем, что ожидается вызывающий код. Если продолжать говорить на примерах из логирования, то следуя этому принципу стоит выделить интерфейс, который отвечает за то, куда именно будет писать лог - IOutput, чтобы пользователь мог взять написанный логер, написать свою реализацию этого интерфейса (писать логи не на консоль, а отправлять на внешнюю API). экземпляр интерфейса будет передаваться в конструктор и станет точкой расширения.

Более архитектурные примеры из реальной жизни - это реализация поддержки разных баз данных в EntityFramework. Сам пакет содержит только базовую логику и не содержит логики работы с определённой базой. Но есть много разных пакетов, как например, EntityFramework.SqlServer, который содержит логику работы с SqlServer и дополняет реализацию. Соответствуя принципу OCP появляется возможность спроектировать решение отдельно от выбора окончательной реализации и без проблем перейти с одной на другую.

### Liskov Substitution Principle (Принцип подстановки Лисков)

Если упростить, то принцип говорит о том, что должна быть возможность вместо базового типа подставить любой его подтип. Одним из нарушений принципов является каст аргументов к более конкретным типам. Так например, если передаётся аргумент типа T, а внутри метода проверяется, является ли он производным типов T2, то логика выполнения для T и T2 является разной

Ещё одну проблему, с который связан принцип Лисков, наглядно можно продемонстрировать на примере двух классов Прямоугольника и Квадрата.

```csharp
class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
     
    public int GetArea() => Width * Height;
}
 
class Square : Rectangle
{
    public override int Width
    {
        get => base.Width; 
        set
        {
            base.Width = value;
            base.Height = value;
        }
    }
 
    public override int Height
    {
        get => base.Height;
 
        set
        {
            base.Height = value;
            base.Width = value;
        }
    }
}

void ProcessRectangle(Rectangle rect)
{
    rect.Width = 20;
    rect.Height = 10;
    var area = rect.GetArea();
    ...
}
```

### Interface Segregation Principle (Принцип разделения интерфейсов)

"Не вынуждайте пользователей реализовывать или зависеть от того, чего им не требуется"

При нарушении этого принципа клиент, использующий некоторый интерфейс со всеми его методами, зависит от методов, которыми не пользуется, и поэтому оказывается восприимчив к изменениям в этих методах. В итоге мы приходим к жесткой зависимости между различными частями интерфейса, которые могут быть не связаны при его реализации.

В этом случае интерфейс класса разделяется на отдельные части, которые составляют раздельные интерфейсы. Затем эти интерфейсы независимо друг от друга могут применяться и изменяться. В итоге применение принципа разделения интерфейсов делает систему слабосвязанной, и тем самым ее легче модифицировать и обновлять.

Пример из реальной жизни:

У вас может быть МФУ для печати, сканирования и отправки факсов, три в одном, всё в одном устройстве. А могут быть три отдельных устройства.

Как не нужно:

```csharp
interface IDevice
{
    void Print(...);
    void Fax(...);
    void Scan(...);
}
```

Как правильно:

```csharp
interface IPrinter
{
	void Print(...);
}

interface IFax
{
	void Fax(...);
}

interface IScanner
{
	void Scan(...);
}

class MultifunctionalDevice : IPrinter, IFax, IScanner 
{
    // Implements...
    public void Print(...);
    public void Fax(...);
    public void Scan(...);
}
```

## Dependency Inversion Principle (Принцип инверсии зависимостей)

- inversion of control

Принцип инверсии зависимостей утверждает, что реализация должна зависеть от абстракции, а не наоборот. Например, при проектировании бизнес логики, которая работает с базой, можно выделить два класса - BusinessLogic и Database. В этом случае класс BusinessLogic будет зависеть от Database. Если Database - это логика, которая работает с базой, то она содержит много особенностей базы. А значит бизнес логика приложения также зависит от этих особенностей.

```plantuml

class Presentation
class BusinessLogic
class Database

Presentation --|> BusinessLogic
BusinessLogic --|> Database

```

DIP принцип утверждает, что это не правильно. И один из способов исправить ситуацию и соответствовать принципу - это выделить абстракции. Для Database можно ввести интерфейс IDatabase и использовать его.

```plantuml

package Core {
    interface IDatabase
    class BusinessLogic

    BusinessLogic --|> IDatabase
}

package Database.MsSql {
    class Database

    Database ..|> IDatabase 
}

package PresentationLayer {
    class Presentation

    Presentation --|> BusinessLogic
    Presentation --|> Database
}

```

На уровне классов мы получили бизнес логику, которая не зависит от деталей реализации базы, а только от одного интерфейса. На уровне проектов мы получили возможность отделить в отдельный проект реализацию MS SQL, а также сделать другую реализацию этого интерфейса и подключить нужную на уровне конфигурации приложения (в нашем случае в Presentation)

Мы должны избегать зависимости от неустойчивых конкретных элементов системы. То есть от модулей, которые продолжают активно разрабатываться и претерпевают частые изменения.
