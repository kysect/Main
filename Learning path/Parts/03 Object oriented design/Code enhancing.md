# Code enhancing

## OOP vs static

Не смотря на том, что многие языки являются объектно-ориентированными, почти у всех есть кейворд `static`. Объявляя метод статическим, к нему можно обращаться без экземпляра класса, которому метод принадлежит. Например, `Console.Write`, `Math.Pow`. Но есть ряд проблем, которые должны заставить задуматься.

Статические методы усложняют переход к полиморфному поведению. Если мы использовали `Console.Write` - это значит, что мы явно привязываемся к типу. Если появится необходимость начать использовать `File.Write`, то нужно будет менять во всех местах. Решением проблемы является экземпляр класса, который будет вызываться - `output.Write`, который в дальнейшем может быть заменён интерфейсов. Стоит также добавить, что в новых версиях C# появилась возможность в интерфейсе определять как статические методы, так и реализацию по-умолчанию (*место для шутки про "разница интерфейса и абстрактного класаа*). Используя эти фичи, можно решить поставленную задачу и без отказа от статических методов, но это применимо только к C#

## Аргументы методов и конструкторов

Допустим, у нас был метод, который переводит числа в слова и пишет на консоль - `ToString(int value)`. Спустя какое-то время появилась необходимость выводить не только на консоль, все выводы логировать, использовать несколько языков. Получаем сигнатуру `ToString(int value, IOutput output, ILogger, logger, LanguageType languageType)`. Пока это не выглядит проблемой, хотя для перевода уже понадобилось пройтись по всем использованиям и добавить аргументы. Обратить внимание в данном случае нужно именно на контракт, которые предоставляется. Если мы проектируем метод, который должен принимать число и возвращать строку, то так оно и должно быть. Остальные аргументы в данном случае являются конфигурацией самого экземпляра типа, который содержит метод. Такие конфигурационные аргументы должны передаваться в конструктор и не изменять сигнатуру метода. Но акцент нужно сделать на том, что была описана ситуация, где контракт таковым является. Если мы перебираем пользователей и хотим для каждого отправить сообщение на его языке, то `LanguageType` уже может стать полноценным аргументом, а не инфраструктурным аргументом, которы мы хотим задать один раз.

Описанный выше подход не всегда работает. Одна из проблем - это ситуация, когда мы не имеем одного из инфраструктурного аргумента на момент создания экземпляра:

```csharp
var message = ...;
IMessenger messenger = new Messenger(output);

foreach (var user in users)
{
    var logger = GetSpecificLoggerForUser(user);
    messenger.Send(user, message, logger);
}
```

В таких случаях может показаться, что логер перестал быть инфраструктурным аргументов и стал полноценным, но с точки зрения бизнес-логики нас он всё ещё мало волнует. Очень часто такие проблемы оставляют, но конкретно эту можно решить созданием ещё одной реализации Messanger:

```csharp
class LoggerMessenger : IMessenger
{
    private Messenger _inner;

    void Send(User user, Message message)
    {
        var logger = GetSpecificLoggerForUser(user);
        _inner.Send(user, message, logger);
    }
}

var message = ...;
IMessenger messenger = new LoggerMessenger(new Messenger(output));

foreach (var user in users)
{
    messenger.Send(user, message);
}

```

## Апкасты как нарушение контракта

Со времён, когда в языке не было дженериков (хотя я не уверен, что хоть кто-то из читателей не джавистов это застал), практиковались не типизированные коллекции. Открыв любую статью про дженерики, можно сразу же увидеть описание проблемы - безопасность типов. Если у нас используется object вместо типа, то мало гарантий, что там нужный нам тип, а не какой-то другой. И более того, если в условный массив, где лежали строки, положить инт, то код падал не во время компиляции и даже не во время того, как инт пытались добавить, а только на попытке прочитать инт как строку. Эту проблему решили вводом дженериков для коллекций, но её не очень часто хотят решать в других местах. Не ушли из моды методы вида:

```csharp
public interface IHandler
{
    void Do(object argument);
}

void Do(object argument)
{
    MySpecificArgument correctArgument = (MySpecificArgument)argument;
    return correctArgument.Result;
}
```

После появления такого кода, мы уже не можем слепо полагаться на сигнатуру, мы должны знать детали реализации. Это прямое нарушение абстракции. В сложных системах, подобные решения появляются очень часто. Это связано со сложностью интерфейсов и невозможностью изменить интерфейс этот. Но для простых решений, появление такие конструкций может означать только плохую проработку контракта. Решением таких ситуаций может быть использование более конкретного типа в интерфейсе или добавление дженериков:

```csharp
public interface IHandler<T>
{
    void Do(T argument);
}

public class Handler : IHandler<MySpecificArgument>
{
    void Do(MySpecificArgument argument)
    {
        return argument.Result;
    }
}

```

## Инкапсуляция как способ скрыть контроль состоянием

Одна из сложностей написания кода - это количество информации, которое нужно держать в голове. Ещё сложнее, когда держать в голове нужно то, чего там не было изначально - код, который написал другой человек. Объектно-ориентированный подход является способ уменьшения количества информации за счёт абстрагирования и сокрытия. Но только при условии, что это сделано правильно. Рассмотрим пример с написанием типа, который должен хранить в себе дату. Один из вариантов - это создать `Tuple<int, int, int>`. И это пример абстракции, которая не уменьшает объем информации, которую нужно держать в контексте. Мы просто сложили три числа в одну переменную, но должны помнить в каком порядке они лежат. Следующий вариант:

```csharp
class Date
{
    public int Day {get; set;}
    public int Month {get; set;}
    public int Year {get; set;}
}
```

Такой вариант вариант решает проблему - он добавляет очевидной семантики. Но когда мы начинаем его использовать, то вспоминаем, что помимо хранения, эти данные ещё могут меняться. А правила изменения у них не всегда очевидны и о них нужно помнить. Например, добавляя день к дате, может оказаться, что следующего дня нет в этом месяце и нужно добавить месяц. Это как раз тот момент, когда разработчику, который будет использовать написанный класс, нужно помнить про эти особенности. Также ему требуется верить, что данные, которые записаны в типе до его изменений, валидные и не нарушают правила. Альтернативный вариант - проверять во всех местах валидность типа. В объектно ориентированном программировании есть такой термин как "инвариант типа". Инвариант - это свойства типа, который остаются неизменными. И речь не про свойства в C#, а скорее про том, что как бы не менялся экземпляр типа, номер месяца не должен быть меньше 1. Поддержка инвариантов - одна из задач, которую должен ставить перед собой разработчик типа, чтобы пользователю не приходилось думать о поддержке инварианта.

Способы поддержки:

1. Инициализировать все нужные поля в конструктор. Если тип не требует дополнительных изменений после создания, то снижается вероятность, что кто-то забудет их сделать.
2. Валидация аргументов внутри типа. Передаваемые аргументы должны валидироваться. И чем раньше эта валидация будет выполнена - тем быстрее будет обнаружена проблема. В идеале, не валидный экземпляр не должен создаваться, должна фейлиться валидация в конструкторе.
3. Закрывать внешнему доку возможность менять экземпляр без проверок. Это касается сеттеров, в которых может попасть не валидное значение.
4. Инкапсуляция. Если тип будет внутри содержать всю логику, то коду из-вне будет сложнее получить ошибку. Например, вместо того, чтобы делать `date.Day = date.Day + 1`, типу нужно добавить метод `void AddDay(int count)`, который бы внутри правильно инкрементил день и проверял, нужно менять месяц.

## Много перегрузок, которые вызывают друг друга

Ещё один случай забивания интерфейса не нужными вещами - это транзитивные методы. Допустим, у нас есть класс для логирования. У него был метод для логирования, который начал расширяться в несколько методов, чтобы из названия выводился уровень логирования, возможность задавать отступа, чтобы создавать вложенность, возможность передавать эксепшен в лог. В итоге может получится очень много методов. Разумеется, что большинство методов просто докидывают аргументов и вызывают один главный, который уже пишет. Такая модель работает отлично, пока не нужно будет выделить интерфейс и сделать вторую реализацию. 

## Наследовать или не наследовать

- Наследование и инкапсуляция - ProductList : Dictionary<Product, ProductInfo>

> TODO: I1

## Зачем нужен кодстайл

## Нейминг, семантика

- Семантический нейминг: Get/Find и null, Try***
- Магические константы

## Минимизация требований к входным параметрам требования к входным параметрам

- Противопоставление подходу с компайл тайм валидацией (типы для Id, MemorySize)

## Минимизация вложенностей

- Стараться минимизировать вложненность за счет инвертирования условий.
- Старайтесь вместо множества вложенных операторов выделить все граничные условия и обработать их в самом начале метода для достижения большей читаемости кода.
см. [https://refactoring.guru/ru/replace-nested-conditional-with-guard-clauses](https://refactoring.guru/ru/replace-nested-conditional-with-guard-clauses)
