# Disposable

## Управление освобождаемыми ресурсами

В языках, которые имеют GC, можно не думать о том, как и когда будет освобождаться память и удаляться объект. Но работает это не для всех объектов. Некоторые объекты ассоциированы с другими объектами вне кода. Например, файловые потоки. В C# можно открыть поток чтения из файла и работать с ним. При этом, сам объект потока будет удерживать файловый дескриптор. Он будет не давать другим процессам или потокам работать с файлом. Если такой объект создать и не освободить дескриптор, то не будет возможности с файлом работать, пока где-то за кулисами не будет дескриптор освобождён (если будет!).

Для того, чтобы работать с подобными освобождающимися ресурсами, в C# введён интерфейс IDisposable, который имплементять типа, которые имеют какую-то логику освобождения. Интерфейс содержит один метод Dispose. Для этого интерфейса есть отдельный синтаксический сахар - `using`. Это связано с тем, что помимо вызова метода, нужно гарантировать, что вызываться он будет всегда, особенно при возникновении ошибок.

```csharp
void F()
{
    IDisposable value;
    try
    {
        value = new Resourse();
        value.Do();
    }
    finally
    {
        value?.Dispose();
    }
}

void F2(IDisposable value)
{
    using (IDisposable value = new Resourse())
        value.Do();
}
```

Тут и далее будем под ресурсами (для упрощения) называть экземпляры IDisposable, а под очисткой/освобождением - вызов метода Dispose. Помимо уменьшения количества кода, `using` уменьшает шанс, что пользователь забудет вызвать метод Dispose или потеряет его при копировании кода. Также, ввиду единого интерфейса для освобождаемых ресурсов, существуют встроенные анализаторы кода, которые могу находить участки кода, где ресурсы не освобождаются.

## Кто отвечает за ресурс

Частая проблема управления ресурсами состоит в том, что не очевидно, кто должен ресурсы освобождать. Например, когда мы создаём объект, который реализует IDisposable, то оборачиваем его в using – всё просто. Но что, если мы передаём такой экземпляр внутрь какого-то метода? Можем ли мы гарантировать, что внутри метода не будет закеширован этот объект, который впоследствии будет задиспоужен, но при этом сохранён где-то в кеше, что означает вероятность обращения к нему – уже задиспоуженному объекту? Или если такой объект будет задиспоужен в методе, то получится так, что мы дважды будем его диспоузить (внутри метода и через использование конструкции using)! Рассмотрим самые частые ситуации и вопросы.

Кто должен освобождать ресурсы? Однозначно ответить сложно. Усложняет ситуацию то, что наш код может использовать другие решения, которые имеют свои представления о работе с ресурсами. Но в ситуации, когда всем кодом можно управлять, применяют подход, когда ресурсы освобождает тот, кто их получил. Очень способствует этому синтаксис using, он форсит нас к тому, чтобы сразу объявить и создание, и освобождение.

А если ресурс передаётся аргументом, то что с ним делать? Его можно использовать, но его не стоит диспоузить, т.к. вызывающему коду будет не очевидно, почему его объект уже не может быть использован. Если при этом ресурс необходимо сохранить внутри класса, который получает ресурс, то такой класс должен транзитивно становиться IDisposable. Это значит, что любой класс, который содержит в качестве полей IDisposable, должен диспоузится.

Значит, если я не буду вызывать .Dispose на ресурсе, который прокидывается аргументом, то никаких проблем не возникнет? До тех пор, пока не будет вызвано освобождение неявно. Одна из таких ловушек описана чуть выше в качестве совета. Если мы создадим класс, передадим ему ресурс, а потом его задиспоузим, то ему очень захочется задиспоузить его. Есть ли уверенность, что `using (var reader = new StreamReader(stream))` не будет вызывать stream.Dispose?

А что делать с тем, что Dispose вызывается дважды? Краткий ответ - ничего, страдать. Решить проблему довольно сложно, т.к. всё завязывается на детали реализации кода другими разработчиками. Единственный хороший момент – это рекомендации Майкрософта по имплементации паттерна Disposable. В них указано, что метод Dispose нужно реализовывать так, чтобы повторный вызов ничего не ломал. Из грустных моментов – это работает не всегда: даже стандартные TcpClient бросают ошибки при повторном вызове Dispose.

Нужно ещё отметить очень очевидный момент. Dispose – это метод экземпляра и вызывается на нём. Из этого следует очень неприятный вывод: "нельзя вызвать Dispose, если нет объекта". Представим ситуацию, что в конструкторе создаётся два экземпляра класса Stream и сохраняются в поля. Разумеется, что мы помним про то, что их нужно освобождать и в методе Dispose будем это делать. А теперь представим, что мы создали первый экземпляр, а на создании второго упали с ошибкой. Вызывается ли освобождение созданного экземпляра? Нет. Мы упали в конструкторе, не успели создать экземпляр, а значит не можем вызывать метод Dispose. В этой ситуации using не сильно то поможет и нужно контролировать выполнение с помощью try-catch и соответствующе обработать такую ситуацию.
