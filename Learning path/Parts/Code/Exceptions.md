# Exceptions

- Контекст ошибок, понятный мессадж, не просто "Не валидное имя", а "Не валидное имя - {groupName}"
- Кастмные ошибки, как способ определить сломалось что-то внутри библиотеки или её неправильно используют

## Exceptions vs error code

Эксепшены - это подход обработке исключительных ситуаций, когда код может прервать выполнение сообщив об ошибке и не будет выполнять  дальнейшие инструкции прерывая выполнение методов вверх по сетку до момента, пока исключение не будет обработано. Обычно, такой подход противопоставляется подходу с кодами возврата, который был популярен в языках С и подобных до появления идеи exception'ов (и после в языке Go и остальных). Выброшенное исключение обычно содержит информацию о том, что именно произошло, чтобы на него можно было отреагировать. При этом, исключения не должны быть частью логики приложения. Они остаются исключительными ситуациями, когда код не может исправить ситуацию на том уровне, где он находится. Например, если консольное приложение требует вводить от пользователя число, а он вводит не число, то обработка ввода не может никак это исправить и просто сообщает вызывающей стороне (в нашем случае консоли, с которой пользователь вводит данные) о том, что произошла ошибка. Альтернативное решение - использовать значение по-умолчанию, если данные не удаётся обработать. В описанной ситуации это выглядит странно, но всё же можно было обработать ошибку, которую мы получили при обработке ввода пользователя и в ответ на неё проигнорировать ввод и подставить значение, которое на этот случай определено. В разработке подобное подавление ошибок встречается в UI, когда приложение во время возникновения ошибки уведомляет об этом пользователя по средствам UI, но при это не пробрасывает дальше и не заканчивает работу. С другой стороны, если ошибки игнорировать, то можно привести систему в невалидное состояние. Например, проигнорировав ошибку сохранения данных в файл, в дальнейшем может оказаться, что какая-то логика нарушена ввиду отсутствия нужных данных. Или же вызывающий код не узнает о возникновении и не сможет отреагировать на него. Например, если приложение получит ошибку о том, что файл не удаётся открыть без админских прав, то она может обработать ошибку и запросить права у пользователя.

## Try* vs try/catche

В базовой библиотеке C#'а есть много встроенных ошибок - ArgumentException, NullReferenceException и прочее. Они используются в стандартных библиотеках, где добавлено много проверок. Но это не значит, что нужно на них полагаться. При разработке код стоит не забывать про валидацию в своём коде. Разработчик в контексте своего приложения накладывает какие-то требования к данным с которыми работает его приложение. Он может более полно описать требования к аргументам и проблему, которая возникает.

Допустим, мы пишем приложение, которое работает со студентами и знаем, что студенты принадлежат группам с названиями похожими на "M3605", и что третья цифра - это номер курса. Вероятно, в коде появится логика, которая парсит 3-ий символ строки в число. Что случится, если на вход подать строку, где 3-ий символ - это буква? Если вызвать метод int.Parse на букве, то он кинет ошибку о невозможности спарсить значение. Пока мы держим в голове этим правила и знаем, что вызвался только этот метод, мы вспомним, что это проблема в букве. Но если мы со стороны пользователя получаем ошибку "Не удалось спарсить `Y` в число", то полезного в этом мало. Решением этой проблемы является safe-проверка на возможность спарсить значение:

```csharp
if (!int.TryParse(groupName[2], out int result))
    throw new ArgumentException($"Cannot get course number from group name: {groupName}");
```

В данном случае использовался метод TryPare, которые не бросает ошибку, но сообщает о невозможности выполнить парсинг. Это даёт возможность разработчику в случае не успешности парсинга бросать свою ошибку, в которой будет больше деталей. Тогда пользователь получит ошибку "Cannot get course number from group name: M3Y05" и с большей вероятностью поймёт в чём именно ошибка. В таких ошибках важно указывать детали по которым можно восстановить проблему (например, название группы, которое не удалось обработать из примера).

## Хендлинг ошибок, потеря кол стека

Во время бросания ошибки, система сохраняет call stack того метода, в котором ошибка возникла. Эти кол стеки дают возможность понимать где именно полетел NullReference, например, чтобы не проверять весь проект. При этом, есть ситуации, когда этот стек может быть потерян при обработке ошибок:

```csharp
try {...}
catch (Exception e) {throw e;} 
```

В описанном выше сценарии у эксепшена появится новый кол стек от данного метода, а оригинальный будет утерян. Если есть необходимость добавить дополнительную информацию об ошибке, можно бросить новый эксепшен, а оригинальный вложить в него. У эксепшена есть конструктор, который помимо сообщения принимаем inner exception. Так например, можно прокинуть ошибку с указанием, что не удалось выполнить какую-то операцию, а внутрь вложить эксепшен, в котором будет указана причина с оригинальным эксепшеном.
