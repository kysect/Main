# Архитектура кода

## Высокоуровневый и низкоуровневый код

Архитектура код всегда строится вокруг бизнес логики. Под бизнес логикой будет подразумевать описание сущностей, правил и логики работы доменной области, автоматизация которой является целью разработки. Например, описывая приложение для магазина, таким можно назвать всё, что касается работы с товарами, продажами и прочим. Но при этом, есть ещё логика работы UI или с базой данных. Бизнес логика не имеет ценности без других инфраструктурных элементов.

## Циклические зависимости

В языке C# разрешаются зависимости между любыми типами внутри одной сборки, но между проектами они могут быть только древовидные - иначе проекты не смогут скомпилироваться. Это значит, что проекты не образуют циклическую зависимость, а классы внутри одного проекта могут. Такое разрешение сильно упрощает разработку обычному пользователю простого приложения - можно написать любое количество классов, делать вызовы между ними. Но если масштабировать этот подход на уровень проекта с несколькими компонентами в одном проекте, можно получить ситуацию, когда UI зависит от бизнес логики, а бизнес логика от UI. Конечно, можно на этапе написания кода не допускать такого, но проблема в том, что такие ошибки очень сложно детектить. На этом моменте можно вспомнить, что C# на уровне проектов запрещает циклические зависимости и использовать эту особенность, чтобы гарантировать, что бизнес логика не зависит от UI. Таким образом, используя разделения на проекты, можно гарантировать некий минимальный уровень архитектуры кода.

## Каплинг и кохижен

- Сильная связность (аккаунт тыкает клиента, клиент тыкает банк)

Разделяя проект на подпроекты можно столкнуться с непониманием как правильно выделять эти модули и сделать это не правильно. Оценить разделение модулей можно по критерию связанности. На примере магазина мы можем представить, что в его бизнес логике содержится много кода связанного с подсчётом скидок, специальных акций и подобного. Такой код между собой сильно пересекается, так как это всё бизнес правила формирования цены. Выделив в отдельный проект этот код, мы получиться сильно связанные между собой классы, которые решают одну задачу. Возьмём эту же идею и применим к логике формирования чеков - он может быть бумажный (с логикой печати), электронный с отправкой на почту (с логикой работы с письмами) или в формате сообщений (с логикой работы с SMS). В этой ситуации мы не получим связанность не смотря на то, что логика схожая. Каждый отдельный описанный пункт может быть хорошим кандидатом на выделение, но вместе они не будут формировать связанный проект.

Ещё один критерий оценки - зацепление. Представим, что весь магазин написан в одном проекте, у нас нет идей как его распилить на несколько, а хочется. Мы можем вспомнить принцип "разделяй и властвуй" и поделить его пополам на два проекта. Вероятность того, что у нас не появится циклических зависимостей, крайне мала, но допустим мы живём в той вселенной, где это получилось. Мы получили два проекта, которые стали меньше и вероятно их проще поддерживать. Но что-то внутри должно подсказывать, что это не лучшая идея. И это что-то - это зацепление. Зацепление - это мера связанности модулей, то, насколько много связей между двумя модулями. Если ещё раз посмотреть на модуль подсчёта скидок, то там скорее всего будет очень небольшое количество точек вхождения, а различные сценарии будут сокрыты внутри модуля, нам не нужно будет знать из чего он состоит. В случае же случайного разделения мы получим большое количество зависимостей между элементами, которые вызывают друг друга. Ни один из этих модулей не является самостоятельным или заменяемым.

## DIP, модули, границы модулей

> TODO: I2

## Жесткость и гибкость в проектировании архитектуры

> TODO: I2

## Многослойная архитектура

Существует много подходов к разделению проекта на большие логические части. Один из самых популярных - это многослойная архитектура. Обычно, под многослойной архитектурой подразумевают три слоя - Presentation, Business logic, Data access. Важно не путать многослойную архитектуру кода и трёхзвенную архитектуру приложения. Трёхзвенная архитектура приложения описывается тремя компонентами - приложение, сервер и база данных. Многослойная архитектура же описывает архитектуру сервера из трёхзвенной архитектуры.

Presentation - это слой представления, слой, который отвечает за взаимодействие с пользователем. То, из чего именно состоит этот слой, зависит то типа приложения. Например:

- Если мы имеем консольное приложение, то слой представления будет содержать в себе логику чтения введённых данных от пользователя, её парсинг, а также вывод результатов на консоль.
- Если мы имеем десктопное приложение, то это логика отрисовки окон, отображение данных и считывание их
- Если мы имеем веб приложение, то это всё, что касается чтения запроса, его парсинг, вызов нужной логики и отправка нужного респонса.

## Чистая архитектура

> TODO: I2

## Луковая архитектура

> TODO: I2

## Горизонтальные и вертикальные слайсы

> TODO: I2

## Source

- [How to create better code using Domain-Driven Design](https://altkomsoftware.pl/en/blog/create-better-code-using-domain-driven-design/)
- [DDD, Hexagonal, Onion, Clean, CQRS](https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/)
- [CQRS + Event Sourcing](https://danielwhittaker.me/2020/02/20/cqrs-step-step-guide-flow-typical-application/)
