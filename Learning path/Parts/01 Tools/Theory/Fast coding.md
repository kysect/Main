# Код

Несмотря на то, что написание кода - это довольно интеллектуальная работа, местами она всё же довольно рутинная. Настолько рутинная, что её можно автоматизировать и ускорить, чтобы тратить меньше времени на бездумные тыки по клавишам и больше времени удалять написанию сложного кода.

## Поиск

Попробуем посмотреть на более приближенные примеры - как код писать и как его читать. Начнем со чтения т.к. код всё же приходится больше читать чем писать. Возможно, это не так очевидно, когда дело касается университетских лабораторных, которые сделались за ночь. Но как только руки доходят до больших проектов - становится понятно, что большую часть времени будет занимать чтение и это нормально. Во время такого перехода ранее тривиальные задачи обретают совершенно иной объем сложностей. Казалось бы, что мешает взять и пройтись по папкам, чтобы найти где лежит какой-то класс? Наверное то, что в проекте файлов резко стало несколько сотен, папки исчисляются десятками, а желание смотреть после 6-ого файла уже нет. Именно в такой ситуации нужно вспомнить про инструменты для разработки. Если конкретно про описанный случай, то решения будут сводиться к поисковым тулзам. Рассмотрим функционал, который предоставляет Visual studio + Resharper для решения этих задач:

- Поиск текста. Решарпер умеет делать как полнотекстовый поиск по всей кодовой базе, так и "умный поиск" по названиям классов. Через Ctrl+T можно ввести первый буквы слов в названии и он справится с тем, чтобы найти их.
- Поиск референсов. Если нужно понятно как и где используется свойство, то на нём можно выполнить поиск референсов и получить список мест, где к нему обращаются.
- Дерево вызовов. Более информативным может стать поиск через дерево вызовов. Вызвав такой поиск на методе, можно получить список мест, где используется метод и одним кликом по каждому из мест также получить дерево их вызовов. Как бонус - древовидность, можно посмотреть где используется метод который использует интересующий метод и так дойти до самого старта программы.
- Построение дерева наследования и реализаций. Т.е. для типа (или его метода) можно в один хоткей посмотреть наследников (или реализации в наследниках в случае метода).

## Снипеты (Live templates)

Переходим к написанию кода. Первым шагом, после автокомплита, является использование сниппетов. Снипеты - это специальные сокращения, которые разворачиваются в код, если их написать, а потом тыкнуть таб:

- ctor, ctorp, ctorf - снипет, который создаёт конструктор типа, в котором сейчас пишется код. Если использовать -p, то конструктор создаётся с аргументами, которые соответствуют публичный свойствам типа, а в самом конструкторе происходит их инициализация. Если использовать -f, то тоже самое произойдёт с приватными полями
- .if после булевой переменной - это снипет, который развернёт код `value.if` в `if (value) { ... }`
- Аналогично работают .foreach, .while, .for, .try, .using
- .not инвертирует условие делая из `if (value.not)` `if (!value)`
- Если автокомплита и теймплейтов не хватет - есть лайфтемплейты от ZenSharp. Это расширение для решарпера, которое превратит объявление любого поля класса в написание 3-4 символов ([https://github.com/ulex/ZenSharp](https://github.com/ulex/ZenSharp))

## Resharper

- Рефакторинги - ренеймы, вынос в метод
- генерация лейблов енама
- Ренейм. Решарпер умеет это делать очень хорошо! Он предложит переименовать связанные классы, если они содержат подстроку, или переменные этого типа, если у нее совпадает имя хоть ка-кто
- Автоимплементация интерфейсов. Если класс должен реализовать интерфейс, то ваш код прекрасно знает какие методы должны там быть и может сам сгенерировать их сигнатуру
- Перемещение порядка аргументов в метода, удаление не используемых в вызывающем код - это все тоже не стоит делать руками.

Каждый раз, когда вы делаете какое-то шаблонное действие, стоит задуматься "а могут ли инструменты сделать это за меня?". Ведь таких микромоментов очень много и они все выстраиваются в одну большую оптимизацию.

> TODO: I2