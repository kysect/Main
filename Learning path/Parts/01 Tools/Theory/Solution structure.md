# Solution structure

Солюшен - это контейнер, который состоит из проектов, которые в свою очередь состоят из файлов с кодом. Более подробно почитать можно тут - <https://docs.microsoft.com/en-us/visualstudio/ide/creating-solutions-and-projects?view=vs-2022>. Проекты используются для того, чтобы разделить большое сложное решение на несколько более простых и менее объемных. Чтобы они проект мог использовать код из другого проекта, добавляется зависимость на этот проект. Зависимости добавляются в рамках одного солюшена. Помимо зависимостей от проектов есть ещё зависимость от фреймворка и nuget-библиотек. Солюшен представлен как .sln файл, который содержит перечисление добавленных в него проектов

В солюшене помимо проектов можно ещё создавать директория. Это может понадобиться, когда в проекте появляется много проектов и их нужно сгруппировать. Например:

- директория для тестов, если таких несколько
- директория для проектов слоя представления (если в проекте поддерживается GUI, CUI и Web API)
- директория для инфраструктурных проектов, например проекты с логикой работы с базой
- директория для основных проектов, содержащих бизнес логику

Структура:

```text
NewSolutionName/
|   Tests/
|   |   NewSolutionName.Tests/
|   |   |   NewSolutionName.Tests.csproj
|   NewSolutionName.Project1/
|   |   NewSolutionName.Project1.csproj
|   NewSolutionName.sln
```

Проекты имеет более сложную метадату. В минимальном виде он состоит из версии dotnet'а, который используется, типа проекта и зависимостей (как от других проектов, так и от нюгетов). Виды проектов:

- Class library - проект для библиотек, дял кода, который не должен запускаться, а только использоваться в других проектах. Большинство проектов именно таковыми и являются
- NUnit/xUnit/MSTest - несколько видов проектов для тестов, которые используют разные инструменты для тестирования. NUnit из них самый распространённый.
- Console app - консольное приложение, которое использует консоль для взаимодействия с пользователем
- ASP.NET/Blazor/WPF - проекты для разработки приложений с использованием соответствующего фреймворка
- VSIX - проект для создания расширений для Visual Studio

## Нейминг солюшенов, папок, проектов и неймспейсов

Нейминг - это всегда сложности, но дальше будут рассмотрены общие паттерны, а не идеи для названий. Основное названием даётся солюшену. Оно обычно содержит идентифицирующие название, иногда компании названием. Например - `Kysect.Tamgly`. Если при создании нового солюшена выбрать не пустой солюшен, а какой-то проект, то будет создан по-умолчанию проект с таким же именем (но это можно менять в визарде создания). Это удобно для солюшенов с одним проектом (когда создаётся что-то для теста). Но хорошим тоном является создание проектов с более семантическим неймингом. Имя проекта должен содержать имя солюшена и только потом дополнение, которое описывает назначение проекта - `Kysect.Tamgly.Tests`, `Kysect.Tamgly.ConsoleClient`.

Названия проектов влияют на неймспейсы, который форсятся для созданных файлов. Так например, файл, который лежит в проекте Kysect.Tamgly.ConsoleClient в директории Core, будет иметь неймспейс Kysect.Tamgly.ConsoleClient.Core. С этим бывает две проблемы:

- При разработке сложного проекта появляется большое количество вложенных директорий, неймспейсы становятся длинными, а их количество быстро растёт. Становится очень не удобно работать с кодом, а его рефакторинг аффектит сразу большое количество файлов, если файл перенести в другую директорию.
- Если назвать директорию также, как и файл, то компилятор перестанет справляться с резолвом. Имея директорию Shop и класс Shop, у вас не будет больше возможности обратиться к классу напрямую т.к. произойдёт коллизия и нужно будет писать Shop.Shop (сначала указываем неймспейс, где лежит, а потом название класса)

## Как переименовать или переместить проект в солюшене

Важно отметить, что директории в солюшене не синхронизированы с директориями на файловой системе (как это происходит в проекте с файлами). Если в солюшене создать проект, а потом добавить директорию и переместить его туда, то он не переместиться на файловой системе. Аналогичная ситуация с переименованием. Если вы случайно создали проект с неправильным названием, а потом переименовали, то директория с проектом продолжит называться неправильно. К сожалению, нормально исправить такую ситуацию сложно:

1. В первую очередь, перед тем, как перемещать или переименовывать директорию с проектом, проще всего начать с удаления всех зависимостей других проектов на него и с него. Это связано с тем, что зависимости прописываются в csproj файле как относительные пути и сломаются после переноса. Если планируется только переименование, до зависимости можно оставить т.к. путь останется, но при переносе относительные пути сломаются.
2. Проект имеет смысл заэксклюдить из солюшена, закрыть солюшен и студию.
3. Не обязательно, но можно удалить папку .vs и файл *.suo
4. Найти директорию с проектом, сделать необходимые изменения
5. Открыть студию с солющеном, на нужной папке (или солюшене, если нужно в корень добавить) тыкнуть Add > Existing project..., выбрать нужный проект
6. Добавить нужные зависимости обратно

## Служебные директории bin и obj

Если создать пустой проект, собрать его, запустить, а потом посмотреть на файловую систему, то можно обнаружить там появление двух папок - obj/ и bin/. Первая используется для хранения временных объектов, которые участвуют в компиляции. После компиляции они не несут никакой ценности и просто висят в папке. Это одна их тех служебных папок, которая, хоть и находится в проекте, не должна попадать в репозиторий с исходным кодом, а должна игнорироваться. Вторая папка чуть более важная, в неё складывается результат билда. Когда мы собираем проект, то получаем на выходе .dll файл. Помимо собираемого проекта, нужны ещё файлы библиотек и самого фреймворка. Они также при билде копируются в эту папку. Из этой папки и выполняется запуск, если делать его через IDE. Также всегда можно открыть папку с уже собранным проектом и запустить его. В самой папке есть особая структура. В корне лежат папки Debug и Release, которые содержат собранные проекты в соответствующем режиме.

Расположение файлов начнёт иметь значение в первый же раз, когда захочется считать что-то с файла или найти в какой файл запись происходила. Вероятно, это и будет папка `bin/debug/...`. Если нужно запустить код, который будет читать с файла и подсунуть туда файл, то лучше всего не подсовывать руками файлы, а воспользоваться инструментами сборки. Для этого в IDE в свойствах файлы (выбрать файл и нажать alt+enter) выбрать действие `Copy on build: Always`. После этого во время сборки файл автоматически будет подкладываться в нужное месте и лишних действий делать не нужно. Но важно учитывать, что это копирование и оригинальный файл изменяться не будет. Если всё же нужен способ изменять оригинальный файл, то нужно будет костылять с путями (об этом далее).

Что касается работы с путями, то она будет происходить относительно папки, где был выполнен запуск. Выполнив команду `File.Create("file.txt")` мы получил файл, который будет лежать в bin/... рядом с файлом dll в который был собран проект. Аналогично чтение также будет происходить. И при особом желании, можно поиграться с `../../` и достать любой файл, который лежит в проекте с исходным кодом.

## Nuget. Основная идея

В экосистеме dotnet существует пакетный менеджер Nuget. Пакетные менеджеры позволяют не хранить вместе с исходным кодом проекта все его библиотеки, а только указывать зависимость на них. При этом, библиотеки будут скачиваться при попытке восстановить и запустить проект, но сохраняться будут отдельно, смогут шариться между проектами. Nuget также отвечает за контролем версий пакетов, обновлением их до актуальной версии и нахождением проблем с их восстановлением. Сам пакет - это архив, в котором лежит собранная dll. Во время билда из этих пакетов достаются длл и закидываются в папку в bin. Пакеты могут иметь зависимости от других пакетов, тогда они будут подгружаться и восстанавливаться вместе с другими пакетами. В IDE есть инструменты, чтобы подключать и удалять подключенные библиотеки. Информация о том, что к проекту подключили нюгет, хранится в csproj.

Каждый нюгет имеет версию. В том числе версии имеют зависимости. Одна из проблем, которая существует из зависимостями - это так называемый dll hell. Представим, что у нас есть проект, который зависит от двух библиотек (А и B), каждая из которых зависит от ещё одной библиотеки (C). Проблемы появляются, когда библиотека A и B требуются разные версии библиотеки C. Тогда система сборки не будет понимать какую именно версию нужно восстановить. Такие проблемы иногда можно решить указывая не конкретную версию, а интервал - например [10.0.0 - 11.0.0).

## Создание своих нюгетов

Для того, чтобы создать нюгет достаточно в настройках проекта в IDE включить генерацию во время билда и тогда вместе с dll в bin будет появляться .nuspec файл. Для того, чтобы глобально делиться библиотеками можно воспользоваться nuget.org. Более детальный гайд доступен тут - https://docs.microsoft.com/en-us/nuget/quickstart/create-and-publish-a-package-using-visual-studio?tabs=netcore-cli.

## Sources

- <https://docs.microsoft.com/en-us/visualstudio/ide/creating-solutions-and-projects?view=vs-2022>