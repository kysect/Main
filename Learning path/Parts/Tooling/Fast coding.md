# Код

## Resharper

## Как вынести много кода и минимум всего делать руками

- Решарпер и всё подобное
- Как быстро и эффективно переписать много кода на примере выноса кода из проекта


Туду вещь все же вариативная, абстрактная, попробуем посмотреть на более приближенные примеры - как код писать и как его читать. Начнем со второго. Сразу проговорю банальную фразу - "код редко пишут и часто читают". Возможно, это не так очевидно, когда дело касается университетских лабораторных, которые сделались за ночь. Но как только руки доходят до больших проектов - становится понятно, что большую часть времени будет занимать чтение и это нормально. Во время такого перехода ранее тривиальные задачи обретают совершенно иной объем сложностей. Казалось бы, что мешает взять и пройтись по папкам, чтобы найти где лежит какой-то класс? Наверное то, что в проекте файлов резко стало несколько сотен, папки исчисляются десятками, а желание смотреть после 6-ого файла уже нет. Именно в такой ситуации нужно вспомнить про инструменты для разработки. Если конкретно про описанный слушая, то решения будут сводиться к поисковым тулзам. Для C#'а есть прекрасная вещь Resharper, хотя и сама Visual Studio умеет делать приятно. Три фичи без которых я бы не смог читать код:

- Поиск текста. Решарпер умеет делать как полнотекстовый поиск по всей кодовой базе, так и "умный поиск" по названиям классов.
- Поиск использований и value origin. Это функционал который я хотел сделать руками, когда впервые попал на большой проект (тогда еще не знал, что решарпер умеет это делать так хорошо) - построение дерева вызовов метода. Т.е. тыкнув один хоткей на метода можно сразу посмотреть все места где метод вообще используется, а не ходить и искать. Как бонус - древовидность, можно посмотреть где используется метод который использует интересующий метод и так дойти до самого старта программы.
- Построение дерева наследования и реализаций. Т.е. для типа (или его метода) можно в один хоткей посмотреть наследников (или реализацию в случае метода).

Важным аспектом также является нейминг. Я встречал людей, которые горели на придирки к названиям и это вызывало у меня вопросы. Давая название классу вы можете как объяснить читателю причину существования класса и название, так и ввести в заблуждение и создать ложное чувство понимания происходящего. Это одна из причин почему следует таки уделить внимания изучению паттернов (понимать что значат слова "Билдер" и "Адаптер") и всяким абстрактным вещам как Domain Design (научиться разделять логику на сущности так, чтобы их понимали другие). Немного апнув свои навыки чтения можно хорошо так сэкономить время на его чтение - понимать суть классов не рассматривая его детали.

Но что же про написание кода? Тут все просто эффективность можно измерить объемом кода, который за вас пишут ваши инструменты. Мой любимый пример - это работа с enum'ами. Имея код

```csharp
<code>
```

Можно одним движением сгенерировать подготовленный оператор switch, который будет 

содержать все параметры enum'а:

```csharp
<code>
```
И это просто спасение. Каждый раз, когда вы делаете какое-то шаблонное действие, стоит задуматься "а могут ли инструменты сделать это за меня?". Ведь таких микромоментов очень много и они все выстраиваются в одну большую оптимизацию. Набросаю небольшой список того, что советую попробовать открыв C#-проект (можете прямо сейчас в своем todo-листе завести задач!):

- Ренейм. Решарпер умеет это делать очень хорошо! Он предложит переименовать связанные классы, если они содержат подстроку, или переменные этого типа, если у нее совпадает имя хоть ка-кто
- Автоимплементация интерфейсов. Если класс должен реализовать интерфейс, то ваш код прекрасно знает какие методы должны там быть и может сам сгенерировать их сигнатуру
- Инверсия условий. Я думаю не мне одному приходилось иногда менять местами текст в if и else по разным причинам. Это довольно простое действие, которое за вас тоже могут сделать инструменты!
- Кажется, метод стал слишком большим? Не беда, решарпер может за вам вынести его кусок в другой метод! (или наоборот заинлайнить)
- Перемещение порядка аргументов в метода, удаление не используемых в вызывающем код - это все тоже не стоит делать руками.
- ctor, ctorp, prop - это мастхев шаблоны, которые пишут код.

А если вы познали дзен - нельзя останавливаться! Ведь есть много расширений освоив которые можно писать код быстрее, приятнее и не отвлекаясь на ерунду:

- Если автокомплита не хватет - есть лайфтемплейты, например ZenSharp. Это расширение для решарпера, которое превратит объявление любого поля класса в написание 3-4 символов ([https://github.com/ulex/ZenSharp](https://github.com/ulex/ZenSharp))
- Если вам повезло меньше и вы не пишете на C# - для вас все равно найдется что-то полезное! Например, если у вас постоянно дергается глаз от упоротых SQL-скриптов а писать как-то нужно - есть форматеры, которые за вас будут проблемы отступов и всего такого ([https://www.apexsql.com/sql-tools-refactor.aspx](https://www.apexsql.com/sql-tools-refactor.aspx))

Но работа с кодом не ограничивается написанием его. Приходится работать с системами контроля версий, которые тоже отнимают время. Например, наслушавшись других разработчиков можно поставить себе консоль и пытаться через нее работать с гитхабом убивая весь UX и усложняя даже простые вещи. Да, люди, которые много лет работали так - привыкли, даже могу поверить, что у них первоманс больше, но если за плечами нет такого опыта, а работа с гитом может еще вызывать трудности - перекладывайте их на GUI для GIT'а. Например, GitKraken. За довольно короткое время использования можно найти те пару кнопок, которые нужно наживать и все уже будет казаться более прозрачным. Написание команд будет сводиться к тыканию на нужные кнопки, а просмотр истории - на скролинг в GUI. Например, с помощью GitKaraken можно создать репозитория сразу на гитхабе, закомитить и запушить туда свои изменения. Или удобно создать и отправить пул-реквест в чем-то репозиторий - это все находится в одном месте и имеет интуитивный интерфейс.

Не забывайте про существования библиотек. Помните, что скорее всего вашу задачу (или ее подтаску) уже кто-то пытался решить. Если вы задумываетесь о написании собственного парсера HTML - остановитесь, подумайте еще раз хотите ли вы этого или же вам достаточно просто взять готовую библиотеку и написать 10 строчек для решения проблемы?