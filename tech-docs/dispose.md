# How to: dispose

Тут и далее будем под ресурсами (для упрощения) называть экземпляры IDisposable, а под очисткой - вызов метода Dispose.
Частая проблема управления ресурсами состоит в том, что не очевидно, кто должен ресурсы освобождать. Например, когда мы создаём объект, который реализует IDisposable, то оборачиваем его в using – всё просто. Но что, если мы передаём такой экземпляр внутрь какого-то метода? Можем ли мы гарантировать, что внутри метода не будет закеширован этот объект, который впоследствии будет задиспоужен, но при этом сохранён где-то в кеше, что означает вероятность обращения к нему – уже задиспоуженному объекту? Или если такой объект будет задиспоужен в методе, то получится так, что мы дважды будем его диспоузить (внутри метода и через использование конструкции using)! Рассмотрим самые частые ситуации и вопросы.

Кто должен освобождать ресурсы? Однозначно ответить сложно. Усложняет ситуацию то, что наш код может использовать другие решения, которые имеют свои представления о работе с ресурсами. Но в ситуации, когда всем кодом можно управлять, применяют подход, когда ресурсы освобождает тот, кто их получил. Очень способствует этому синтаксис using, он форсит нас к тому, чтобы сразу объявить и создание, и освобождение.

А если ресурс передаётся аргументом, то что с ним делать? Его можно использовать, но его не стоит диспоузить, т.к. вызывающему коду будет не очевидно, почему его объект уже не может быть использован. Если при этом ресурс необходимо сохранить внутри класса, который получает ресурс, то такой класс должен транзитивно становиться IDisposable. Это значит, что любой класс, который содержит в качестве полей IDisposable, должен диспоузится.

Значит, если я не буду вызывать .Dispose на ресурсе, который прокидывается аргументом, то всё ок? До тех пор, пока не будет вызвано освобождение неявно. Одна из таких ловушек описана чуть выше в качестве совета. Если мы создадим класс, который, передадим ему ресурс, а потом его задиспоузим, то ему очень захохчется задиспоузить его. Есть ли уверенность, что `using (var reader = new StreamReader(stream))` не будет вызывать stream.Dispose?

А что делать с тем, что Dispose вызывается дважды? Краткий ответ - ничего, страдать. Решить проблему довольно сложно, т.к. всё завязывается на детали реализации кода другими разработчиками. Единственный хороший момент – это рекомендации Майкрософта по имплементации паттерна Disposable. В них указано, что метод Dispose нужно реализовывать так, чтобы повторный вызов ничего не ломал. Из грустных моментов – это работает не всегда: даже стандартные TcpClient бросают ошибки при повторном вызове Dispose.

Нужно ещё отметить очень очевидный момент. Dispose – это метод экземпляра и вызывается на нём. Из этого следует очень неприятный вывод: "нельзя вызвать Dispose, если нет объекта". Представим ситуацию, что в конструкторе создаётся два экземпляра класса Stream и сохраняются в поля. Разумеется, что мы помним про то, что их нужно освобождать и в методе Dispose будем это делать. А теперь представим, что мы создали первый экземпляр, а на создании второго упали с ошибкой. Вызывается ли освобождение созданного экземпляра? Нет. Мы упали в конструкторе, не успели создать экземпляр, а значит не можем вызывать метод Dispose. В этой ситуации using не сильно то поможет и нужно контролировать выполнение с помощью try-catch и соответствующе обработать такую ситуацию.